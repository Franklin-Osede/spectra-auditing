// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.20;

import "forge-std/Test.sol";

/**
 * @title SimplifiedCurvePoolVulnerability
 * @dev Demonstrates the mathematical vulnerability in CurvePoolUtil.previewRemoveLiquidity
 * @notice This is a minimal demonstration without external dependencies
 */
contract SimplifiedCurvePoolVulnerability is Test {
    // Events to replace console.log
    event TestInfo(string message);
    event ValueInfo(string name, uint256 value);
    event PercentageInfo(string name, int256 value);
    
    // Constants for testing
    uint256 constant CURVE_UNIT = 1e18;
    uint256 constant POOL_INITIAL_IBT = 1_000_000 * 1e18; // 1M IBT
    uint256 constant POOL_INITIAL_PT = 1_000_000 * 1e18;  // 1M PT
    uint256 constant TOTAL_LP_SUPPLY = 2_000_000 * 1e18;  // 2M LP tokens
    uint256 constant VICTIM_LP_AMOUNT = 100_000 * 1e18;   // 100k LP tokens (5% of pool)
    uint256 constant APPROXIMATION_DECREMENT = 1;         // Same as in CurvePoolUtil
    
    // Mathematical simulation state
    uint256 ibtBalance;
    uint256 ptBalance;
    uint256 lpTokenSupply;
    
    function setUp() public {
        // Initialize simulation with reasonable values
        ibtBalance = POOL_INITIAL_IBT;
        ptBalance = POOL_INITIAL_PT;
        lpTokenSupply = TOTAL_LP_SUPPLY;
    }
    
    /**
     * @notice Demonstrates the mathematical vulnerability
     * @dev This test shows how the same calculation used in CurvePoolUtil.previewRemoveLiquidity
     *      is vulnerable to manipulation via temporary pool imbalance
     */
    function testVulnerabilityInRemoveLiquidityCalculation() public {
        emit TestInfo("STARTING VULNERABILITY TEST: CurvePoolUtil.previewRemoveLiquidity Sandwich Attack");
        
        // Step 1: Calculate what the victim expects to receive under normal conditions
        uint256[2] memory expectedAmounts = calculateRemoveLiquidityAmounts(
            ibtBalance,
            ptBalance,
            lpTokenSupply,
            VICTIM_LP_AMOUNT
        );
        
        emit TestInfo("Expected returns under normal conditions:");
        emit ValueInfo("IBT", expectedAmounts[0] / 1e18);
        emit ValueInfo("PT", expectedAmounts[1] / 1e18);
        
        // Store initial state for later comparison
        uint256 initialIbtBalance = ibtBalance;
        
        // Step 2: Attacker front-runs with a large swap to manipulate the pool
        // Here we simulate a manipulation where the attacker swaps IBT for PT
        uint256 manipulationAmount = initialIbtBalance * 50 / 100; // 50% of pool's IBT
        
        // Simulate a swap that removes IBT and adds PT to the pool
        ibtBalance -= manipulationAmount;
        ptBalance += manipulationAmount * 95 / 100; // 5% slippage
        
        emit TestInfo("Pool state after manipulation:");
        emit ValueInfo("IBT balance", ibtBalance / 1e18);
        emit ValueInfo("PT balance", ptBalance / 1e18);
        
        // Step 3: Calculate what the victim would now receive with manipulated balances
        uint256[2] memory manipulatedAmounts = calculateRemoveLiquidityAmounts(
            ibtBalance,
            ptBalance,
            lpTokenSupply,
            VICTIM_LP_AMOUNT
        );
        
        emit TestInfo("Expected returns after manipulation:");
        emit ValueInfo("IBT", manipulatedAmounts[0] / 1e18);
        emit ValueInfo("PT", manipulatedAmounts[1] / 1e18);
        
        // Step 4: Calculate the impact on the victim
        int256 ibtImpactPercent = int256(manipulatedAmounts[0] * 100) / int256(expectedAmounts[0]) - 100;
        int256 ptImpactPercent = int256(manipulatedAmounts[1] * 100) / int256(expectedAmounts[1]) - 100;
        
        emit TestInfo("Impact on victim's returns:");
        emit PercentageInfo("IBT impact", ibtImpactPercent);
        emit PercentageInfo("PT impact", ptImpactPercent);
        
        // Step 5: Assert that the impact is significant
        assertLt(int256(manipulatedAmounts[0]), int256(expectedAmounts[0]), "IBT amount should be reduced");
        assertGt(int256(manipulatedAmounts[1]), int256(expectedAmounts[1]), "PT amount should be increased");
        
        // The mathematical proof that the vulnerability exists
        assertTrue(
            ibtImpactPercent < -20 || ptImpactPercent > 20,
            "Manipulation should cause at least 20% impact"
        );
        
        emit TestInfo("VULNERABILITY DEMONSTRATED: The formula used in previewRemoveLiquidity is susceptible to sandwich attacks");
        emit TestInfo("because it relies solely on instantaneous pool balances without any manipulation protection.");
    }
    
    /**
     * @notice Simplified calculation simulating CurvePoolUtil.previewRemoveLiquidity
     * @dev This is the same formula used in the protocol, showing why it's vulnerable
     */
    function calculateRemoveLiquidityAmounts(
        uint256 _ibtBalance,
        uint256 _ptBalance,
        uint256 _totalSupply,
        uint256 _lpTokenAmount
    ) internal pure returns (uint256[2] memory minAmounts) {
        // This is equivalent to the code in CurvePoolUtil.previewRemoveLiquidity
        if (_lpTokenAmount > APPROXIMATION_DECREMENT && _totalSupply != 0) {
            _lpTokenAmount -= APPROXIMATION_DECREMENT;
            minAmounts = [
                (_ibtBalance * _lpTokenAmount) / _totalSupply,
                (_ptBalance * _lpTokenAmount) / _totalSupply
            ];
        } else {
            minAmounts = [uint256(0), uint256(0)];
        }
    }
} 