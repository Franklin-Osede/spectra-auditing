# Critical Vulnerability: Sandwich Attack on CurvePoolUtil Preview Functions

## Overview

During a comprehensive security review of Spectra Finance's codebase, I discovered a critical vulnerability in the `CurvePoolUtil` library. Specifically, the functions `previewRemoveLiquidity`, `previewRemoveLiquidityNG`, and `previewRemoveLiquiditySNG` are vulnerable to sandwich attacks due to their reliance on current pool balances without protection against manipulation. This vulnerability could allow malicious actors to extract value from users removing liquidity from Curve pools, leading to significant financial losses.

## Vulnerability Details

### Affected Components

The vulnerability exists in the following functions within `src/libraries/CurvePoolUtil.sol`:

- `previewRemoveLiquidity()` - Lines 94-117
- `previewRemoveLiquidityNG()` - Lines 118-142
- `previewRemoveLiquiditySNG()` - Lines 143-164

These functions are critical as they are used by users interacting with the protocol to predict how many tokens they will receive when removing liquidity from Curve pools. The results are then used to set slippage parameters for transactions.

### Technical Analysis

At the core of the vulnerability is the function `_getCurvePoolBalances()` (line 397), which is called by all three preview functions:

```solidity
function _getCurvePoolBalances(address _curvePool) internal view returns (uint256, uint256) {
    return (ICurvePool(_curvePool).balances(0), ICurvePool(_curvePool).balances(1));
}
```

This function simply returns the current balances of IBT and PT in the pool. The preview functions then use these balances to calculate the expected returns:

```solidity
// From previewRemoveLiquidity
if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {
    _lpTokenAmount -= APPROXIMATION_DECREMENT;
    minAmounts = [
        (ibtBalance * _lpTokenAmount) / totalSupply,
        (ptBalance * _lpTokenAmount) / totalSupply
    ];
} else {
    minAmounts = [uint256(0), uint256(0)];
}
```

The vulnerability arises because:

1. These functions take a direct "snapshot" of current pool balances
2. No time-weighted averaging is implemented
3. No circuit breakers or manipulation detection exists
4. There's no comparison against historical data or other oracle sources

### Attack Vector

An attacker can exploit this vulnerability through a sandwich attack following these steps:

1. **Front-running**: Monitor mempool for transactions calling functions that use `previewRemoveLiquidity` (e.g., `RouterUtil.previewRemoveLiquidityForAsset`). When a potential victim is identified, the attacker executes a transaction that temporarily manipulates pool balances by performing a large swap.

2. **Manipulation**: By swapping a significant amount of one token for another, the attacker creates an imbalance in the pool. For example, removing 50% of IBT and adding PT would significantly reduce the calculated return of IBT for users.

3. **Victim's Transaction**: The victim's transaction executes with the manipulated balances, causing them to receive fewer tokens than they would under normal conditions.

4. **Back-running**: The attacker then executes another transaction to restore the pool balance, profiting from the difference.

## Proof of Concept

I've created a mathematical proof of concept in `SandwichAttack.t.sol` that demonstrates this vulnerability without relying on external dependencies. The test:

1. Initializes a simulated pool with 1M IBT, 1M PT, and 2M LP tokens
2. Calculates the expected returns for a user withdrawing 100k LP tokens under normal conditions
3. Simulates an attacker manipulating the pool by removing 50% of IBT and adding PT (with 5% slippage)
4. Recalculates the returns with manipulated balances
5. Compares the difference to quantify the impact

When executed, the test shows:

- Normal conditions: User expects approximately 50,000 IBT and 50,000 PT
- After manipulation: User receives approximately 25,000 IBT and 75,000 PT
- Impact: -50% for IBT, +50% for PT

This represents a significant deviation that would bypass typical slippage protections of 1-3%.

## Real-world Impact

### Financial Consequences

1. **Direct User Losses**: Users could receive significantly fewer tokens than expected. With a 50% manipulation of IBT in a pool, users could lose up to 25% of the total value they expect to receive.

2. **MEV Extraction**: The vulnerability creates substantial MEV opportunities. In pools with $10M+ TVL, a 1% extraction could yield $100,000 in profit for attackers.

3. **Cumulative Effect**: Since these functions are used in all liquidity removal operations, the vulnerability affects a significant portion of protocol interactions.

### Protocol Risks

1. **User Trust**: Frequent exploitation would erode trust in the protocol, as users consistently receive less value than expected.

2. **Systemic Risk**: As this vulnerability affects a core component (CurvePoolUtil), multiple protocol functions that rely on it (like Router functions) are impacted.

3. **Competitive Disadvantage**: Most modern DeFi protocols implement protections against such manipulations, making Spectra stand out negatively.

## Affected Usage Flows

The vulnerability impacts several key flows in Spectra Finance:

1. **Direct Liquidity Management**: Users removing liquidity through the Router's liquidityManagement module.

2. **Asset Swap Operations**: Functions that rely on previewRemoveLiquidity to calculate expected returns for swaps involving LP tokens.

3. **Project Integrations**: Third-party protocols that integrate with Spectra and rely on these preview functions.

### Notable Impacted Functions in RouterUtil:

- `previewRemoveLiquidityForAsset`
- `previewRemoveLiquidityForIBT`
- `previewRemoveLiquidity`
- `previewNGRemoveLiquidityForAsset`
- `previewNGRemoveLiquidityForIBT`
- `previewNGRemoveLiquidity`

## Code Analysis & Attack Flow Trace

Let's trace how this vulnerability manifests in the protocol flow:

1. **User Interaction**: A user calls `Router.execute()` with commands to remove liquidity from a Curve pool.

2. **Preview Calculation**: The transaction uses `RouterUtil.previewRemoveLiquidity()` to determine min amounts, which calls `CurvePoolUtil.previewRemoveLiquidity()`.

3. **Vulnerable Point**: `CurvePoolUtil.previewRemoveLiquidity()` calls `_getCurvePoolBalances()` which reads current pool balances directly.

4. **Attack Vector**: An attacker can manipulate these balances just before the user's transaction executes.

5. **Impact Point**: The user receives fewer tokens than expected but within their slippage tolerance, so their transaction succeeds despite the manipulation.

## Recommended Mitigations

### Short-term Solutions

1. **Implement Circuit Breakers**: Add validation logic to detect and prevent abnormal balance changes:

```solidity
function _validatePoolBalances(address _curvePool, uint256 ibtBalance, uint256 ptBalance) internal view {
    // Get historical balances (e.g. from storage or using oracles)
    (uint256 prevIbtBalance, uint256 prevPtBalance) = getHistoricalBalances(_curvePool);
    
    // Check for significant deviations
    uint256 ibtDev = abs(ibtBalance, prevIbtBalance) * 100 / prevIbtBalance;
    uint256 ptDev = abs(ptBalance, prevPtBalance) * 100 / prevPtBalance;
    
    require(ibtDev <= MAX_ALLOWED_DEVIATION && ptDev <= MAX_ALLOWED_DEVIATION, 
        "Balance change exceeds safety threshold");
}
```

2. **Use Time-Weighted Balances**: Modify the `_getCurvePoolBalances` function to use time-weighted averages:

```solidity
function _getCurvePoolBalances(address _curvePool) internal view returns (uint256, uint256) {
    // Implement TWAP for balance readings
    return ICurvePoolTWAP(_curvePool).getTimeWeightedBalances(TIME_PERIOD);
}
```

### Long-term Solutions

1. **Implement TWAP Oracles**: Develop and integrate time-weighted average price oracles for all Curve pools:

```solidity
function previewRemoveLiquidity(
    address _curvePool,
    uint256 _lpTokenAmount
) external view returns (uint256[2] memory minAmounts) {
    address lpToken = ICurvePool(_curvePool).token();
    uint256 totalSupply = IERC20(lpToken).totalSupply();
    (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolTWAPBalances(_curvePool, 3600); // 1-hour TWAP
    
    // Continue with calculation using TWAP values
    // ...
}
```

2. **Multi-Source Validation**: Implement multiple sources for validating expected returns:

```solidity
function getValidatedRemoveLiquidityAmounts(address _curvePool, uint256 _lpTokenAmount) external view 
    returns (uint256[2] memory) {
    
    // Get amounts from multiple sources
    uint256[2] memory directAmounts = _getDirectPoolAmounts(_curvePool, _lpTokenAmount);
    uint256[2] memory twapAmounts = _getTWAPPoolAmounts(_curvePool, _lpTokenAmount);
    uint256[2] memory oracleAmounts = _getOraclePoolAmounts(_curvePool, _lpTokenAmount);
    
    // Validate across sources and return most conservative estimate
    return _getMostConservativeAmounts(directAmounts, twapAmounts, oracleAmounts);
}
```

3. **Oracle Integration**: For critical pools, integrate with trusted external oracles like Chainlink:

```solidity
function getVerifiedRemoveLiquidityAmounts(address _curvePool, uint256 _lpTokenAmount) external view 
    returns (uint256[2] memory amounts) {
    
    amounts = previewRemoveLiquidity(_curvePool, _lpTokenAmount);
    
    // Cross-validate with oracle
    if (oracleRegistry.hasOracleFor(_curvePool)) {
        uint256[2] memory oracleAmounts = oracleRegistry.getOracleAmounts(_curvePool, _lpTokenAmount);
        require(_isWithinTolerance(amounts, oracleAmounts), "Oracle validation failed");
    }
    
    return amounts;
}
```

## Discovery Process

This vulnerability was discovered through a methodical code review process:

1. Initial identification of the dependency on direct pool balances in CurvePoolUtil.
2. Analysis of the mathematical calculations used in the preview functions.
3. Verification that no protection mechanisms exist against balance manipulation.
4. Creation of a mathematical proof of concept to quantify the potential impact.

## References

1. CurvePoolUtil.sol (src/libraries/CurvePoolUtil.sol)
2. RouterUtil.sol (src/router/util/RouterUtil.sol)
3. SandwichAttack.t.sol (test/vulnerability/curvepool/SandwichAttack.t.sol)
4. "Flash Loans and Decentralized Price Oracles" (2020) by Qin, Zhou, and Gervais
5. "High-Frequency Trading on Decentralized Exchanges" (2021) by Zhou et al.

## Conclusion

The vulnerability in CurvePoolUtil's preview functions represents a significant risk to users of Spectra Finance. By relying directly on current pool balances without manipulation protection, these functions expose users to potential sandwich attacks that could result in substantial financial losses. The mathematical proof demonstrates that even with conservative parameters, attackers could extract significant value from user transactions.

Given the critical nature of these functions and their widespread use throughout the protocol, addressing this vulnerability should be a high priority. Implementing TWAP mechanisms, circuit breakers, or oracle validation would significantly improve the security posture of Spectra Finance. 