// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.20;

import "forge-std/Test.sol";
import "../../src/interfaces/IStableSwapNG.sol";
import "../../src/interfaces/IPrincipalToken.sol";
import "../../src/interfaces/IRateAdjustmentOracle.sol";
import "../../src/libraries/RayMath.sol";

/**
 * @notice Mock Implementation of StableSwapNG for testing purposes
 * @dev This mock simulates a Curve pool that can be manipulated via flash loans
 */
contract MockStableSwapNG {
    using RayMath for uint256;

    address public ibt;
    address public pt;
    uint256 public lastPrice = 0.95e18; // 95% of unit - typical PT price
    
    mapping(uint256 => uint256) public balances;
    
    constructor(address _ibt, address _pt) {
        ibt = _ibt;
        pt = _pt;
        balances[0] = 1_000_000e18; // IBT balance
        balances[1] = 1_000_000e18; // PT balance
    }
    
    function coins(uint256 i) external view returns (address) {
        if (i == 0) return ibt;
        if (i == 1) return pt;
        revert("Invalid coin index");
    }
    
    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256) {
        require(i < 2 && j < 2 && i != j, "Invalid indices");
        
        // Simulate price impact based on trade size
        uint256 dy;
        uint256 priceImpact = (dx * 1e18) / balances[i];
        
        if (i == 0 && j == 1) {
            // Buying PT with IBT
            uint256 adjustedPrice = (lastPrice * (1e18 - priceImpact / 2)) / 1e18;
            dy = (dx * adjustedPrice) / 1e18;
            lastPrice = adjustedPrice;
        } else {
            // Selling PT for IBT
            uint256 adjustedPrice = (lastPrice * (1e18 + priceImpact / 2)) / 1e18;
            dy = (dx * 1e18) / adjustedPrice;
            lastPrice = adjustedPrice;
        }
        
        balances[i] += dx;
        balances[j] -= dy;
        
        // Update PT rate to reflect price change - this is the key vulnerability
        MockPrincipalToken(pt).setPTRate(RayMath.toRay(lastPrice, 18)); // Convert from 18 decimals to RAY format (27 decimals)
        
        return dy;
    }
}

/**
 * @notice Mock Principal Token implementation
 */
contract MockPrincipalToken {
    uint256 private ptRate = 0.95e27; // 95% of face value (in ray format)
    address public ibt;
    uint256 public maturity;
    
    function initialize(address _ibt, uint256 _duration, address) external {
        ibt = _ibt;
        maturity = block.timestamp + _duration;
    }
    
    function getPTRate() external view returns (uint256) {
        return ptRate;
    }
    
    function setPTRate(uint256 _newRate) external {
        ptRate = _newRate;
    }
}

/**
 * @notice Mock RateAdjustmentOracle implementation showing the vulnerability
 */
contract MockRateAdjustmentOracle {
    uint256 private constant ORACLE_DECIMALS = 18;
    uint256 private constant YEAR = 365 * 24 * 3600;

    address public curvePoolAddress;
    uint256 public initialPrice;
    uint256 public startTime;
    uint256 public expiry;
    
    constructor(address _curvePoolAddress, uint256 _initialPrice) {
        curvePoolAddress = _curvePoolAddress;
        initialPrice = _initialPrice;
        startTime = block.timestamp;
        expiry = block.timestamp + YEAR;
    }
    
    function value() external view returns (uint256) {
        MockStableSwapNG pool = MockStableSwapNG(curvePoolAddress);
        MockPrincipalToken pt = MockPrincipalToken(pool.coins(1));
        
        // The vulnerability: using the PT rate directly from the curve pool
        uint256 ptRate = pt.getPTRate();
        return RayMath.fromRay(ptRate, ORACLE_DECIMALS); // Convert from RAY (27 decimals) to 18 decimals
    }

    function initialize(address) external pure {}
    function post_initialize(uint256, uint256, uint256, address) external pure {}
    function setInitialPrice(uint256) external pure {}
    function getInitialPrice() external view returns (uint256) { return initialPrice; }
    function getCurvePoolAddress() external view returns (address) { return curvePoolAddress; }
    function getStartTime() external view returns (uint256) { return startTime; }
    function getExpiry() external view returns (uint256) { return expiry; }
} 